// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: group_member.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addUserToGroup = `-- name: AddUserToGroup :one
INSERT INTO shen_user_group_member(user_id, group_id)
    VALUES ($1, $2)
RETURNING
    id, user_id, group_id, created_at, updated_at
`

type AddUserToGroupParams struct {
	UserID  int32 `json:"user_id"`
	GroupID int32 `json:"group_id"`
}

func (q *Queries) AddUserToGroup(ctx context.Context, arg AddUserToGroupParams) (ShenUserGroupMember, error) {
	row := q.db.QueryRow(ctx, addUserToGroup, arg.UserID, arg.GroupID)
	var i ShenUserGroupMember
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countAllGroupMembers = `-- name: CountAllGroupMembers :one
SELECT
    COUNT(*)
FROM
    shen_user_group_member
`

func (q *Queries) CountAllGroupMembers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllGroupMembers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countGroupsByUser = `-- name: CountGroupsByUser :one
SELECT
    COUNT(*)
FROM
    shen_user_group_member
WHERE
    user_id = $1
`

func (q *Queries) CountGroupsByUser(ctx context.Context, userID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countGroupsByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsersByGroup = `-- name: CountUsersByGroup :one
SELECT
    COUNT(*)
FROM
    shen_user_group_member
WHERE
    group_id = $1
`

func (q *Queries) CountUsersByGroup(ctx context.Context, groupID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countUsersByGroup, groupID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserGroupMemberByID = `-- name: GetUserGroupMemberByID :one
SELECT
    id,
    user_id,
    group_id,
    created_at,
    updated_at
FROM
    shen_user_group_member
WHERE
    id = $1
LIMIT 1
`

func (q *Queries) GetUserGroupMemberByID(ctx context.Context, id int32) (ShenUserGroupMember, error) {
	row := q.db.QueryRow(ctx, getUserGroupMemberByID, id)
	var i ShenUserGroupMember
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const isUserInGroup = `-- name: IsUserInGroup :one
SELECT
    EXISTS (
        SELECT
            1
        FROM
            shen_user_group_member
        WHERE
            user_id = $1
            AND group_id = $2)
`

type IsUserInGroupParams struct {
	UserID  int32 `json:"user_id"`
	GroupID int32 `json:"group_id"`
}

func (q *Queries) IsUserInGroup(ctx context.Context, arg IsUserInGroupParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserInGroup, arg.UserID, arg.GroupID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listAllGroupMembers = `-- name: ListAllGroupMembers :many
SELECT
    m.id,
    g.name AS group_name,
    u.username AS username,
    m.created_at,
    m.updated_at
FROM
    shen_user_group_member m
    JOIN shen_user u ON m.user_id = u.id
    JOIN shen_group g ON m.group_id = g.id
ORDER BY
    g.name,
    u.username
LIMIT $1 OFFSET $2
`

type ListAllGroupMembersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListAllGroupMembersRow struct {
	ID        int32            `json:"id"`
	GroupName string           `json:"group_name"`
	Username  string           `json:"username"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) ListAllGroupMembers(ctx context.Context, arg ListAllGroupMembersParams) ([]ListAllGroupMembersRow, error) {
	rows, err := q.db.Query(ctx, listAllGroupMembers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllGroupMembersRow
	for rows.Next() {
		var i ListAllGroupMembersRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupName,
			&i.Username,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupsByUser = `-- name: ListGroupsByUser :many
SELECT
    g.id,
    g.name,
    g.active,
    g.created_at,
    g.updated_at
FROM
    shen_user_group_member m
    JOIN shen_group g ON m.group_id = g.id
WHERE
    m.user_id = $1
ORDER BY
    g.name
LIMIT $2 OFFSET $3
`

type ListGroupsByUserParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListGroupsByUser(ctx context.Context, arg ListGroupsByUserParams) ([]ShenGroup, error) {
	rows, err := q.db.Query(ctx, listGroupsByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShenGroup
	for rows.Next() {
		var i ShenGroup
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsersByGroup = `-- name: ListUsersByGroup :many
SELECT
    u.id,
    u.username,
    u.hashed_password,
    u.active,
    u.role,
    u.created_at,
    u.updated_at
FROM
    shen_user_group_member m
    JOIN shen_user u ON m.user_id = u.id
WHERE
    m.group_id = $1
ORDER BY
    u.username
LIMIT $2 OFFSET $3
`

type ListUsersByGroupParams struct {
	GroupID int32 `json:"group_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListUsersByGroup(ctx context.Context, arg ListUsersByGroupParams) ([]ShenUser, error) {
	rows, err := q.db.Query(ctx, listUsersByGroup, arg.GroupID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShenUser
	for rows.Next() {
		var i ShenUser
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.HashedPassword,
			&i.Active,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeUserFromGroup = `-- name: RemoveUserFromGroup :exec
DELETE FROM shen_user_group_member
WHERE user_id = $1
    AND group_id = $2
`

type RemoveUserFromGroupParams struct {
	UserID  int32 `json:"user_id"`
	GroupID int32 `json:"group_id"`
}

func (q *Queries) RemoveUserFromGroup(ctx context.Context, arg RemoveUserFromGroupParams) error {
	_, err := q.db.Exec(ctx, removeUserFromGroup, arg.UserID, arg.GroupID)
	return err
}
