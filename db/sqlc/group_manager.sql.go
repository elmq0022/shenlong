// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: group_manager.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const addManagerToGroup = `-- name: AddManagerToGroup :one
INSERT INTO shen_user_group_manager(user_id, group_id)
    VALUES ($1, $2)
RETURNING
    id, user_id, group_id, created_at, updated_at
`

type AddManagerToGroupParams struct {
	UserID  int32 `json:"user_id"`
	GroupID int32 `json:"group_id"`
}

func (q *Queries) AddManagerToGroup(ctx context.Context, arg AddManagerToGroupParams) (ShenUserGroupManager, error) {
	row := q.db.QueryRow(ctx, addManagerToGroup, arg.UserID, arg.GroupID)
	var i ShenUserGroupManager
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const countAllGroupManagers = `-- name: CountAllGroupManagers :one
SELECT
    COUNT(*)
FROM
    shen_user_group_manager
`

func (q *Queries) CountAllGroupManagers(ctx context.Context) (int64, error) {
	row := q.db.QueryRow(ctx, countAllGroupManagers)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countGroupsManagedByUser = `-- name: CountGroupsManagedByUser :one
SELECT
    COUNT(*)
FROM
    shen_user_group_manager
WHERE
    user_id = $1
`

func (q *Queries) CountGroupsManagedByUser(ctx context.Context, userID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countGroupsManagedByUser, userID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countManagersByGroup = `-- name: CountManagersByGroup :one
SELECT
    COUNT(*)
FROM
    shen_user_group_manager
WHERE
    group_id = $1
`

func (q *Queries) CountManagersByGroup(ctx context.Context, groupID int32) (int64, error) {
	row := q.db.QueryRow(ctx, countManagersByGroup, groupID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getUserGroupManagerByID = `-- name: GetUserGroupManagerByID :one
SELECT
    id,
    user_id,
    group_id,
    created_at,
    updated_at
FROM
    shen_user_group_manager
WHERE
    id = $1
LIMIT 1
`

func (q *Queries) GetUserGroupManagerByID(ctx context.Context, id int32) (ShenUserGroupManager, error) {
	row := q.db.QueryRow(ctx, getUserGroupManagerByID, id)
	var i ShenUserGroupManager
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.GroupID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const isUserManagerOfGroup = `-- name: IsUserManagerOfGroup :one
SELECT
    EXISTS (
        SELECT
            1
        FROM
            shen_user_group_manager
        WHERE
            user_id = $1
            AND group_id = $2)
`

type IsUserManagerOfGroupParams struct {
	UserID  int32 `json:"user_id"`
	GroupID int32 `json:"group_id"`
}

func (q *Queries) IsUserManagerOfGroup(ctx context.Context, arg IsUserManagerOfGroupParams) (bool, error) {
	row := q.db.QueryRow(ctx, isUserManagerOfGroup, arg.UserID, arg.GroupID)
	var exists bool
	err := row.Scan(&exists)
	return exists, err
}

const listAllGroupManagers = `-- name: ListAllGroupManagers :many
SELECT
    m.id,
    g.name AS group_name,
    u.username AS username,
    m.created_at,
    m.updated_at
FROM
    shen_user_group_manager m
    JOIN shen_user u ON m.user_id = u.id
    JOIN shen_group g ON m.group_id = g.id
ORDER BY
    g.name,
    u.username
LIMIT $1 OFFSET $2
`

type ListAllGroupManagersParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListAllGroupManagersRow struct {
	ID        int32            `json:"id"`
	GroupName string           `json:"group_name"`
	Username  string           `json:"username"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
	UpdatedAt pgtype.Timestamp `json:"updated_at"`
}

func (q *Queries) ListAllGroupManagers(ctx context.Context, arg ListAllGroupManagersParams) ([]ListAllGroupManagersRow, error) {
	rows, err := q.db.Query(ctx, listAllGroupManagers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListAllGroupManagersRow
	for rows.Next() {
		var i ListAllGroupManagersRow
		if err := rows.Scan(
			&i.ID,
			&i.GroupName,
			&i.Username,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listGroupsManagedByUser = `-- name: ListGroupsManagedByUser :many
SELECT
    g.id,
    g.name,
    g.active,
    g.created_at,
    g.updated_at
FROM
    shen_user_group_manager m
    JOIN shen_group g ON m.group_id = g.id
WHERE
    m.user_id = $1
ORDER BY
    g.name
LIMIT $2 OFFSET $3
`

type ListGroupsManagedByUserParams struct {
	UserID int32 `json:"user_id"`
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListGroupsManagedByUser(ctx context.Context, arg ListGroupsManagedByUserParams) ([]ShenGroup, error) {
	rows, err := q.db.Query(ctx, listGroupsManagedByUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShenGroup
	for rows.Next() {
		var i ShenGroup
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Active,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listManagersByGroup = `-- name: ListManagersByGroup :many
SELECT
    u.id,
    u.username,
    u.hashed_password,
    u.active,
    u.role,
    u.created_at,
    u.updated_at
FROM
    shen_user_group_manager m
    JOIN shen_user u ON m.user_id = u.id
WHERE
    m.group_id = $1
ORDER BY
    u.username
LIMIT $2 OFFSET $3
`

type ListManagersByGroupParams struct {
	GroupID int32 `json:"group_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) ListManagersByGroup(ctx context.Context, arg ListManagersByGroupParams) ([]ShenUser, error) {
	rows, err := q.db.Query(ctx, listManagersByGroup, arg.GroupID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ShenUser
	for rows.Next() {
		var i ShenUser
		if err := rows.Scan(
			&i.ID,
			&i.Username,
			&i.HashedPassword,
			&i.Active,
			&i.Role,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const removeManagerFromGroup = `-- name: RemoveManagerFromGroup :exec
DELETE FROM shen_user_group_manager
WHERE user_id = $1
    AND group_id = $2
`

type RemoveManagerFromGroupParams struct {
	UserID  int32 `json:"user_id"`
	GroupID int32 `json:"group_id"`
}

func (q *Queries) RemoveManagerFromGroup(ctx context.Context, arg RemoveManagerFromGroupParams) error {
	_, err := q.db.Exec(ctx, removeManagerFromGroup, arg.UserID, arg.GroupID)
	return err
}
